@node Writing applications
@chapter Writing applications

@menu
* Including libraries and linking::  
* Example programs::            
* Writing Qt4 applications::    
* Other programming issues::    
* Interoperability::            
* Using and Extending the Scheduler::
@end menu


@node Including libraries and linking
@section Including libraries and linking

@cindex Compiling, programs
@cindex Linking, programs
To use any marsyas code in your program(s), you need to include the
Marsyas libraries in your project.

@subsection ... using qmake

The easiest way to compile Marsyas programs is to use qmake.  You may do
this even if you used autotools to configure Marsyas itself; the author
of this documentation uses autotools to build Marsyas, and qmake to
build his programs.

Create a @file{my_program_name.pro} file:

@verbatim
#  your files
SOURCES = my_program_name.cpp
#HEADERS += extra_file.h
#SOURCES += extra_file.cpp


### if running inside the source tree
### adjust as necessary:
MARSYAS_INSTALL_DIR = ../../
INCLUDEPATH += $$MARSYAS_INSTALL_DIR/src/marsyas/
LIBPATH += $$MARSYAS_INSTALL_DIR/lib/release/


### if installed elsewhere
#MARSYAS_INSTALL_DIR = /usr/local
#MARSYAS_INSTALL_DIR = ${HOME}/usr/
#INCLUDEPATH += $$MARSYAS_INSTALL_DIR/marsyas/
#LIBPATH += $$MARSYAS_INSTALL_DIR/lib/


### basic OS stuff; do not change!
win32-msvc2005:LIBS += marsyas.lib
unix:LIBS += -lmarsyas -L$$MARSYAS_INSTALL_DIR/lib
!macx:LIBS += -lasound
macx:LIBS += -framework CoreAudio -framework CoreMidi -framework CoreFoundation

@end verbatim

Then type @code{qmake} to generate a Makefile.  Now you many compile
normally.


@subsection ... writing your own Makefile

We @emph{highly} recommend that you use qmake to create a Makefile.
However, if you enjoy swearing at your computer and cursing k&r, rms,
gnu, and every other three-letter programmer acronym in existence,
go ahead. read on.

Here are sample Makefiles to get you started:

@examplefilenewpage{Makefile.linux}
@examplefilenewpage{Makefile.osx}


@subsection ... on Windows Visual Studio

Create the @code{.cpp} and @code{.h} files you will be working
with in the project.  Don't worry about the VS project file, it
will be generated by qmake.

Type @code{qmake -project} at the command line to generate the
.pro file, which Qt uses to create the Makefile (or you can make
your own as above).  Don't worry about linking to external
libraries, we will take care of that in Visual Studio.

Once you have a @code{.pro} file, type

@example
qmake -tp vc -spec win32-msvc2008
@end example

@noindent
Or equivalent based on your system.  This will generate a .vcproj
file.  Open this in Visual Studio.

Navigate to Tools->Options->Projects and Solutions->VC++ Directories and ensure:

@itemize
@item Executable files includes qt's bin directory
Include files includes %qt-root%\include, %marsyas-root%\src\marsyas, %marsyas-root%\src\marsyasqt\, %marsyas-root% (for config.h)

@item Library files include dsdk, marsyas, and qt's lib directories

@item
In project properties->linker:
General-> 
Ignore import libary: No 
Link Library Dependencies: Yes
Input->
Additional Dependencies: add @code{c:\marsyas\build\lib\Release\marsyas.lib
c:\marsyas\build\lib\Release\marsyasqt.lib
"C:\Program Files\Microsoft DirectX SDK (November 2008)\Lib\x86\dsound.lib"
imm32.lib
winmm.lib
ws2_32.lib
}
System->
Subsystem: Console
@end itemize

These settings worked for the author.


@node Example programs
@section Example programs

The most efficient way to learn how to write programs that use MarSystem
is to read these examples.  We recommend that you use these examples as
templates when you begin to write your own programs.

@menu
* Hello World (playing an audio file)::  
* Reading and altering controls::  
* Writing data to text files::  
* Getting data from the network::  
* Command-line options::        
@end menu



@node Hello World (playing an audio file)
@subsection Hello World (playing an audio file)

@cindex Hello world
@cindex Playing an audio file

Instead of printing @qq{Hello World!}, we shall play a sound file.  This is
relatively straightforward: we create a @code{MarSystem} which is a
series of @code{SoundFileSource}, @code{Gain}, and @code{AudioSink}.  Once
the network is created and the controls are given, we call @code{tick()} to
make time pass until we have finished playing the file.

@examplefile{helloworld.cpp}


@node Reading and altering controls
@subsection Reading and altering controls

Here we have modified the example from the previous section: we have added
the ability to start at an arbitrary position (time) inside the audio file.
To calculate the starting position in the file, we must know the sample rate
and number of channels.  We get this information from the
@code{SoundFileSource} with @code{getctrl}.

@examplefile{controls.cpp}


@node Writing data to text files
@subsection Writing data to text files

Extract data from a network for further analysis (plotting,
other programs, etc) is fairly easy to do with @code{PlotSink}.

@examplefile{writefile.cpp}


@node Getting data from the network
@subsection Getting data from the network

Putting together a network of MarSystems is all well and good,
but you probably want to do something with that data.  In this
example we simply print it to the screen, but the important
thing to note is that we have the data at the level of C programming.

@examplefile{gettingdata.cpp}




@node Command-line options
@subsection Command-line options

Getting options from the command-line is fairly easy; Marsyas provides
a handy object which parses the command-line for you.

@examplefile{commandOptions.cpp}


@node Writing Qt4 applications
@section Writing Qt4 applications

Writing applications that use Marsyas and Qt4 is quite simple, thanks to
@file{libmarsasqt}.

@warning{ Marsyas compiled with autotools does not compile
@file{libmarsyasqt} by default.  To enable it, please pass
@code{--enable-marsyasqt} to configure.}

@menu
* Including and linking to libmarsyasqt::  
* MarSystemQtWrapper::          
* Passing controls to a MarSystemQtWrapper::  
* Other classes in MarsyasQt::  
* Qt4 example::                 
* Other Qt4 issues::            
@end menu


@node Including and linking to libmarsyasqt
@subsection Including and linking to libmarsyasqt

Create a @file{.pro} file based on this template:

@verbatim
###  your files
SOURCES = main.cpp
HEADERS = mainwindow.h
SOURCES += mainwindow.cpp
HEADERS += backend.h
SOURCES += backend.cpp


### if running inside the source tree
MARSYAS_INSTALL_DIR = ../../../
INCLUDEPATH += $$MARSYAS_INSTALL_DIR/src/marsyasqt_wrapper/
LIBPATH += $$MARSYAS_INSTALL_DIR/lib/release/


### if installed elsewhere
#MARSYAS_INSTALL_DIR = /usr/local
#MARSYAS_INSTALL_DIR = ${HOME}/usr/
#INCLUDEPATH += $$MARSYAS_INSTALL_DIR/src/marsyas/
#LIBPATH += $$MARSYAS_INSTALL_DIR/lib/


unix:LIBS += -lmarsyas -lmarsyasqt
unix:!macx:LIBS += -lasound
macx:LIBS += -framework CoreAudio -framework CoreMidi -framework CoreFoundation
@end verbatim

It is @strong{highly} recommended that you separate the Qt code (ie
@code{mainwindow.cpp}) from the Marsyas code (ie @code{backend.cpp}).


@node MarSystemQtWrapper
@subsection MarSystemQtWrapper

The actual interaction between Qt and Marsyas is performed with a
@code{MarSystemQtWrapper} object.  Add the following lines to your
header file that deals with Marsyas:

@example
#include "MarSystemQtWrapper.h"
using namespace MarsyasQt;
@end example

You may now create a pointer to a MarSystemQtWrapper in your object:

@example
MarSystemQtWrapper *mrsWrapper;
@end example

To use this object in your source file, create a MarSystem like normal,
then pass it to a new @code{MarSystemQtWrapper} object:

@example
MarSystemManager mng;
playbacknet = mng.create("Series", "playbacknet");
... set up playbacknet...

// wrap it up to make it pretend to be a Qt object:
mrsWrapper = new MarSystemQtWrapper(playbacknet);
mrsWrapper->start();
mrsWrapper->play();

... do something for a while...
mrsWrapper->stop();
delete mrsWrapper;
@end example


@node Passing controls to a MarSystemQtWrapper
@subsection Passing controls to a MarSystemQtWrapper

@cindex MarControlPtr

Since your MarSystem is wrapped up, you cannot access controls using the
normal methods.  Instead, you must use a MarControlPtr:

@example
MarControlPtr filenamePtr;
MarControlPtr positionPtr;

filenamePtr = mrsWrapper->getctrl("SoundFileSource/src/mrs_string/filename");   
positionPtr = mrsWrapper->getctrl("SoundFileSource/src/mrs_natural/pos");

mrsWrapper->updctrl(filenamePtr,fileName);
... wait a bit...
newPos = (mrs_natural) positionPtr->to<mrs_natural>();
@end example


@node Other classes in MarsyasQt
@subsection Other classes in MarsyasQt

MarsyasQt includes more than just @code{MarSystemQtWrapper}.  Please
refer to source documentation in @ref{Library reference}.


@node Qt4 example
@subsection Qt4 example

To get started, look at the Qt4 tutorial files:

@examplefilenewpage{tutorial.pro}
@examplefilenewpage{main.cpp}
@examplefilenewpage{mainwindow.h}
@examplefilenewpage{mainwindow.cpp}
@examplefilenewpage{backend.h}
@examplefilenewpage{backend.cpp}

After examining that project, see @file{apps/Qt4Apps/MarPlayer/}, followed by
the other examples in the @file{apps/Qt4Apps/} directory.


@node Other Qt4 issues
@subsection Other Qt4 issues

TODO: beautify

Question and answer:

@example
I'd like to analyze sound file to extract pitches and amplitudes.  I
have working code without using MarSystemQtWrapper, but for GUI display
reasons, I'd like to do this analysis in a separate thread.  (ie a
MarSystemQtWrapper)

Is there any way to do this kind of thing inside a MarSystemQtWrapper?

        while (allNet->getctrl("mrs_bool/hasData")->toBool())
                allNet->tick(); 
@end example

add the control you are interested to the monitored
controls by calling trackctrl  (or something like that)
in MarSystemQtWrapper. The  MarSystemQtWrapper
will emit a signal either any time the control is changed
or at period intervals depending on the withTimer
settting. Either way you can connect the signal
ctrlChanged(MarControlPtr cname);

to a slot in your GUI and then call allnet->pause()
when that happens. 

-----
this is working on Meaws, but I'll need to read my code again to figure
out how it works.  Fortunately, I write nice clean readable code. :) -gp

UPDATE: look at src/qt4apps/regressionChecks instead.


@subheading Converting between QString and mrs_string

@example
QString qs = "Hello world!"; 
mrs_string mrs_s = qs.toStdString();
@end example

@example
mrs_string mrs_s = "foo.wav";
QString qs = QString( mrs_s.c_str() );
@end example



@node Other programming issues
@section Other programming issues

@menu
* Visualizing data with gnuplot::  
@end menu


@node Visualizing data with gnuplot
@subsection Visualizing data with gnuplot

Gnuplot is an open-source data plotting utility available on every
operating system that Marsyas supports.  More information (including
downloads and installation instructions) can be found on the
@uref{http://www.gnuplot.info/,Gnuplot website}.

Data in Marsyas can be plotted easily: simply write the realvec to
a text file and call gnuplot on the result.

@example
void someFunction() @{
  string filename = "dataToPlot.txt";
	realvec data;
	data.allocate(size);
// ... do whatever processing here...
  data.writeText( filename );
  data.~realvec();
@}
@end example

After compiling and running the program, the @code{dataToPlot.txt} file
may be plotted with gnuplot.

@example
gnuplot> plot "dataToPlot.txt"
@end example



@node Interoperability
@section Interoperability

@menu
* Open Sound Control (OSC)::    
* WEKA::                        
* MATLAB::                      
* Python::                      
* OCaml::        
* SonicVisualiser Vamp Plugins::                 
@end menu

@node Open Sound Control (OSC)
@subsection Open Sound Control (OSC)

@WANTED{@emph{can} be done; read the source code.}


@node WEKA
@subsection WEKA

@WANTED{@emph{can} be done; read the source code.}


@node MATLAB
@subsection MATLAB

MATLAB is a high-level technical computing language and interactive
environment for algorithm development, data visualization, data
analysis, and numeric computation @uref{http://www.mathworks.com/}

Marsyas supports the use of the MATLAB engine API for exchanging data at
runtime between Marsyas C++ code and MATLAB enviroment. This allows
effortlessly passing and getting data to/from MATLAB inside Marsyas, and
have access to MATLAB plotting facilities, numerical routines,
toolboxes, etc.  More information about the MATLAB engine can be found
at
@uref{http://www.mathworks.com/access/helpdesk/help/techdoc/matlab_external/f39903.html,
in their technical documentation}.

@subheading Passing data from Marsyas to MATLAB => MATLAB_PUT()

To export data from Marsyas into MATLAB, simply use the macro
@code{MATLAB_PUT(marsyasVar, MATLABvarName)}.

MATLAB_PUT() can be used with C++ int, float, double, mrs_real,
mrs_natural, mrs_complex, std::string, std::vector, Marsyas::realvec,
among other data types. For a complete list of the types supported,
please refer to @file{src/marsyas/MATLAB/MATLABengine.h}.

@example
//create a Marsyas realvec (i.e. a 2 by 3 matrix):
realvec marsyas_realvec(2,3);
marsyas_realvec(0,0) = 0.0;
marsyas_realvec(0,1) = 0.1;
marsyas_realvec(0,2) = 0.2;
marsyas_realvec(1,0) = 1.0;
marsyas_realvec(1,1) = 1.1;
marsyas_realvec(1,2) = 1.2;

// Send the realvec to MATLAB, and call it marsyasMatrix in MATLAB
MATLAB_PUT(marsyas_realvec,"marsyasMatrix");
// marsyasMatrix is now a normal matrix of doubles in MATLAB
// environment, which can be used as any regular MATLAB matrix.
@end example

Please refer to @file{src/apps/mudbox/mudbox.cpp} for more examples of
using the MATLAB engine API in Marsyas (look for the
toy_with_MATLABengine() function).

@subheading Executing commands in MATLAB from Marsyas C++ code => MATLAB_EVAL()

It is possible to execute commands in MATLAB from Marsyas C++ code, as
if they were being input into the MATLAB command line. For this use the
macro @code{MATLAB_EVAL(command)}.

@example
//create a Marsyas realvec (i.e. a 2 by 3 matrix):
realvec marsyas_realvec(2,3);
marsyas_realvec(0,0) = 0.0;
marsyas_realvec(0,1) = 0.1;
marsyas_realvec(0,2) = 0.2;
marsyas_realvec(1,0) = 1.0;
marsyas_realvec(1,1) = 1.1;
marsyas_realvec(1,2) = 1.2;

// Send the realvec to MATLAB, and call it marsyasMatrix in MATLAB
MATLAB_PUT(marsyas_realvec,"marsyasMatrix");

// now we can, for e.g., ask MATLAB to transpose the passed matrix...
MATLAB_EVAL("marsyasMatrix = marsyasMatrix'");
// and, why not, plot the matrix...
MATLAB_EVAL("imagesc(marsyasMatrix)");
// run our own m.files...
MATLAB_EVAL("myFunction(marsyasMatrix);");
// or execute any other MATLAB command!
MATLAB_EVAL("whos");
// Pretty cool, hum? ;-)
@end example

Please refer to src/apps/mudbox/mudbox.cpp for more examples of using
the MATLAB engine API in Marsyas (look for the toy_with_MATLABengine()
function).

@subheading Getting data from MATLAB into Marsyas => MATLAB_GET()

To import data into Marsyas from MATLAB, simply use the macro
@code{MATLAB_GET(MATLABvarName, marsyasVar);}

MATLAB_GET() can be used for getting data from MATLAB into C++ int,
float, double, mrs_real, mrs_natural, mrs_complex, std::vector,
Marsyas::realvec, among other data types. For a complete list of the
types supported, please refer to src/marsyas/MATLAB/MATLABengine.h. 

@example
//create a Marsyas realvec (i.e. a 2 by 2 matrix):
realvec marsyas_realvec(2,2);
marsyas_realvec(0,0) = 0.0;
marsyas_realvec(0,1) = 0.1;
marsyas_realvec(1,0) = 1.0;
marsyas_realvec(1,1) = 1.1;

// Send the realvec to MATLAB, and call it marsyasMatrix in MATLAB
MATLAB_PUT(marsyas_realvec,"marsyasMatrix");

// now we can, for e.g., ask MATLAB to transpose the passed matrix...
MATLAB_EVAL("marsyasMatrix = marsyasMatrix'");
// and calculate its determinant
MATLAB_EVAL("matrixDet = det(marsyasMatrix);");

// we can now get the determinant value back into Marsyas 
// (note: Marsyas already has its own efficient C++ 
// implementation for determinant calculation of realvecs!
// This is just an example of what can be done with the Marsyas MATLAB engine.
mrs_real det;
MATLAB_GET("matrixDet", det);
cout << det << endl;

// but we can also get the (now transposed) matrix back into Marsyas:
MATLAB_GET("marsyasMatrix", marsyas_realvec);
cout << marsyas_realvec << endl;
@end example

Please refer to src/apps/mudbox/mudbox.cpp for more examples of using
the MATLAB engine API in Marsyas (look for the toy_with_MATLABengine()
function).

@node Python
@subsection Python

Here are instructions for python/ruby SWIG bindings.  These instructions
assume Python and/or Ruby are installed. You might need to install 
a more recent version of Python (for example MacPython from the Python 
website) than the one that comes pre-bundled with OS X depending 
on the version of your system. 

At the top level directory do : 

@enumerate
./configure --enable-bindings 
@item
make 
@item
sudo make install
@end enumerate

Assuming that python and ruby have been locating your bindings 
have been compiled and installed. To check that your bindings 
are installed. 

@enumerate 
@item Start any python IDE or shell (for example python or ipython) 
@item At the prompt type: 
@item import marsyas 
@item If you get no error your bindings have been installed 
@item Go to swig/python 
@item Try some of the examples such as test2.py or bextract.py 
@end enumerate 





@node OCaml
@subsection OCaml

To combine Marsyas and OCaml, see the MarsyasOCaml documentation at
@uref{http://www.cs.uvic.ca/~inb/work/marsyasOCaml/}


@node SonicVisualiser Vamp Plugins
@subsection SonicVisualiser Vamp Plugins
@subsubsection Instalation

@b{Requirements:}
@itemize
@item @b{CMake} (@uref{http://www.cmake.org/}).
@item @b{SonicVisualiser} (@uref{http://www.sonicvisualiser.org/}).
@item @b{Vamp Plugin SDK:}
@itemize
@item Latest revision: @code{$ svn co https://vamp.svn.sourceforge.net/svnroot/vamp/vamp-plugin-sdk/trunk vamp-plugin-sdk}.
@item Distribution: @uref{http://sourceforge.net/projects/vamp/files/vamp-plugin-sdk/}.
@item Build and install the plugin sdk using the supplied instructions.@*
(vamp-simple-host, a command-line host for Vamp plugins, is installed along)
@end itemize
@item @b{Vamp Tester [@strong{optional}]}@*
A command line application for testing plugins, giving you a very detailed report about the compliance of the plugin:
@itemize
@item Latest revision: @code{$ svn co https://vamp.svn.sourceforge.net/svnroot/vamp/vamp-plugin-tester/trunk vamp-plugin-tester}.
@item Distribution (source + binaries): @uref{http://sourceforge.net/projects/vamp/files/vamp-plugin-tester/}.
@item Add vamp-plugin-tester path to environment @code{PATH}.
@end itemize
@end itemize


@strong{MacOSX:}@*
(Tested in 10.6 with gcc 4.2 for i386 and x86_64, linking to both the static and dynamic build of Marsyas.@*
Note that x86_64 is not supported by Sonic Visualiser yet, but fat binaries with both architectures work fine.)

@enumerate
@item @b{Building Marsyas Vamp Plugin:}@*

@itemize
@item @code{$ cmake-gui}@*
@code{WITH_VAMP ON};@*
@code{MARSYAS_STATIC OFF} (static linking not supported)@*
@code{VAMP_LIBRARY}: dynamic/static version of libvamp-sdk, from the install path -> @code{/usr/local/lib/libvamp-sdk.dylib} or @code{/usr/local/lib/libvamp-sdk.a}@*
@code{VAMP_INCLUDE_DIR}: vamp sdk src main path -> @code{/usr/local/include/}@*
(choose your own paths if different)
@item @code{$ make}@*
(If you generate an XCode project, the mvamp target won't be included so you'll need to build using plain "make")@*
(vamp plugin compiled as shared dynamic library at @code{marsyas_path/build_dir/lib/libmvamp.dylib)}
@end itemize

@item @b{Marsyas Vamp Plugin Integration in SonicVisualiser Transforms:}
@itemize
@item Copy @code{libmvamp.dylib} to one of the following paths:
@example
~/Library/Audio/Plug-Ins/Vamp (user use)
/Library/Audio/Plug-Ins/Vamp (system use)
@end example
@end itemize
(@code{mvamp-plugins.cat}, in pre-compiled version or in @code{path/to/marsyas/src/mvamp/}, is a txt file for organizing the plugin functions within SonicVisualiser Transforms - for such you may also copy it to the chosen path above, yet it seems to be unnecessary)

@item @b{(Optional) Testing Plugin with vamp-plugin-tester:}
@itemize
@item @code{$ VAMP_PATH=Path/To/Vamp_Plugins_Directory}
@item @code{$ vamp-plugin-tester -a}
@end itemize

@item @b{(Optional) Testing Plugin with vamp-simple-host:}
@itemize
@item @code{$ VAMP_PATH=Path/To/Vamp_Plugins_Directory}
@item List the plugin libraries and Vamp plugins in the library search path: @code{$ vamp-simple-host -l}
@item Run the plugin: @code{$ vamp-simple-host [-s] pluginlibrary[.dylib]:plugin file.wav [outputno] [-o out.txt]}@*
(check pluginlibrary and plugin name with @code{-l} above)
@end itemize
@end enumerate


@strong{Linux OS:}@*
(Tested in Linux Ubuntu 9.04-32bits with gcc 4.3 -> may work on others)

@enumerate
@item @b{Building Marsyas Vamp Plugin:}@*
(Alternatively simply download pre-compiled plugin for Linux i686 at @uref{http://marsyas.info/download/vamp_plugins})

@itemize
@item @code{$ cmake-gui}@*
@code{WITH_VAMP ON};@*
@code{MARSYAS_STATIC OFF} (static linking not supported)@*
@code{VAMP_LIBRARY}: dynamic/static version of libvamp-sdk, from the install path -> @code{/usr/local/lib/libvamp-sdk.so} or @code{/usr/local/lib/libvamp-sdk.a}@*
@code{VAMP_INCLUDE_DIR}: vamp sdk src main path -> @code{/usr/local/include/}@*
(choose your own paths if different)
@item @code{$ make}@*
(vamp plugin compiled as shared dynamic library at @code{marsyas_path/build/lib/libmvamp.so)}
@end itemize

@item @b{Marsyas Vamp Plugin Integration in SonicVisualiser Transforms:}
@itemize
@item Copy @code{libmvamp.so} (or pre-compiled @code{mvamp.so}) to one of the following paths:
@example
/home/(user)/vamp (user use)
/usr/local/lib/vamp (system use)
@end example
@end itemize
(@code{mvamp-plugins.cat}, in pre-compiled version or in @code{path/to/marsyas/src/mvamp/}, is a txt file for organizing the plugin functions within SonicVisualiser Transforms - for such you may also copy it to the chosen path above, yet it seems to be unnecessary)

@item @b{(Optional) Testing Plugin with vamp-plugin-tester:}
@itemize
@item @code{$ VAMP_PATH=Path/To/Vamp_Plugins_Directory}
@item @code{$ vamp-plugin-tester -a}
@end itemize

@item @b{(Optional) Testing Plugin with vamp-simple-host:}
@itemize
@item @code{$ VAMP_PATH=Path/To/Vamp_Plugins_Directory}
@item List the plugin libraries and Vamp plugins in the library search path: @code{$ vamp-simple-host -l}
@item Run the plugin: @code{$ vamp-simple-host [-s] pluginlibrary[.so]:plugin file.wav [outputno] [-o out.txt]}@*
(check pluginlibrary and plugin name with @code{-l} above)
@end itemize

@end enumerate


@strong{Windows OS:}@*
(Tested in Windows Vista-32bists with VS2008 and Windows 7 with VS2010 -> may work on others)

@enumerate
@item @b{Building Marsyas Vamp Plugin:}@*

@itemize
@item Run CMake-GUI:@*
@code{WITH_VAMP ON};@*
@code{MARSYAS_STATIC OFF} (static linking not supported)@*
@code{VAMP_LIBRARY}: static version of libvamp-sdk -> @code{path\to\vamp-plugin-sdk-x.x\build_dir\Release\VampPluginSDK.lib}@*
@code{VAMP_INCLUDE_DIR}: vamp sdk src main path -> @code{path\to\vamp-plugin-sdk-x.x}@*
(choose your own paths if different)
@item Load @code{marsyas_path\build\Marsyas.sln} in Visual Studio@*
@item Open mvamp project proprieties:@*
@itemize
@item Go to @code{Configuration Properties -> Linker -> Command Line -> Additional options}
@item Add @code{/EXPORT:vampGetPluginDescriptor}
@end itemize
@item Build marsyas + mvamp in Release mode and @strong{in Win32} architecture.@*
(x64 not currently supported by SonicVisualiser)
@end itemize

@item @b{Marsyas Vamp Plugin Integration in SonicVisualiser Transforms:}
@itemize
@item Copy @code{mvamp.dll} from @code{marsyas_path\build\bin\Release\} to @code{C:\Program Files\Vamp Plugins\} (default @code{VAMP_PATH})@*
(if used different path for Vamp Plugins define it in environment @code{VAMP_PATH})
@item Run-time linking to Marsyas (one of the two options below):
@itemize
@item Set @code{marsyas_path\build\bin\Release\} to environment variable @code{PATH}
@item Copy @code{marsyas.dll from marsyas_path\build\bin\Release\} to SonicVisualiser main directory.
@end itemize
@end itemize

@item @b{(Optional) Testing Plugin with vamp-plugin-tester:}
@itemize
@item @code{$ vamp-plugin-tester.exe -a}
@end itemize

@item @b{(Optional) Testing Plugin with vamp-simple-host:}
@itemize
@item List the plugin libraries and Vamp plugins in the library search path: @code{$ vamp-simple-host.exe -l}
@item Run the plugin: @code{$ vamp-simple-host.exe [-s] pluginlibrary[.dylib]:plugin file.wav [outputno] [-o out.txt]}@*
(check pluginlibrary and plugin name with @code{-l} above)
@end itemize

@end enumerate


@subsubsection Writing Plugin

Check tutorial on @uref{http://www.vamp-plugins.org/develop.html}



@node Using and Extending the Scheduler
@section Using and Extending the Scheduler

Writing applications using the scheduler may require writing additional timer
and event types. This section will try to explain how to customize the
scheduler for your own applications.

@menu
* Using the Scheduler::
* Writing a new Timer::
* Writing a new Event::
* Marsyas Expression Syntax::
@end menu

@node Using the Scheduler
@subsection Using the Scheduler

In the example below an event is created and posted to the network to set the
gain control to 0 (silence) two seconds after the network starts processing.
This is accomplished by creating a new EvValUpd event which performs a
@code{setctrl} call when dispatched.

The EvValUpd event requires a MarSystem pointer to
act on - we use the topmost @code{series} object because we have a pointer to
it. The event also requires a control path referenced to the supplied MarSystem
pointer. Finally, it requires a MarControlValue to set the control value to on
dispatch. This value should have the same type as the one specified in the
control path otherwise the Marsyas system will report an error at dispatch
time.

To post the event to a timer the MarSystem @code{updctrl} call is used. The
first parameter to @code{updctrl} is the dispatch time. This indicates a
scheduled event call to the MarSystem and it is passed on to the scheduler.
In this case the @code{TmTime} class is supplied the name of the timer that the
event is to be posted on along with the time of event dispatch. The default
timer for every MarSystem is a @code{TmSampleCount} timer, which counts the
number of samples processed, with the name Virtual. The TmSampleCount timer
understands the units @code{us, ms, s, m, h} corresponding to microseconds,
milliseconds, seconds, minutes, hours, respectively. The supplied time is
converted to samples by calling the static method 
@code{mrs_natural Marsyas::time2samples(string time, mrs_real srate)}
in the @file{Conversions.cpp}.

@float Figure,fig:sch1
@example
  MarSystemManager mng;

  MarSystem* series = mng.@b{create}(@t{"Series"}, @t{"series"});
  series->@b{addMarSystem}(mng.@b{create}(@t{"SineSource"}, @t{"src"}));
  series->@b{addMarSystem}(mng.@b{create}(@t{"Gain"}, @t{"g"}));
  series->@b{addMarSystem}(mng.@b{create}(@t{"AudioSink"}, @t{"snk"}));

  series->@b{updctrl}(@t{"AudioSink/snk/mrs_bool/initAudio"}, @b{true});
  series->@b{updctrl}(@t{"SineSource/src/mrs_real/frequency"},440.0);
  series->@b{updctrl}(@t{"Gain/g/mrs_real/gain"},1.0);

  EvValUpd* ev = @b{new} @b{EvValUpd}(series,@t{"Gain/g/mrs_real/gain"},0.0);
  series->@b{updctrl}(@b{TmTime}(@t{"TmSampleCount/Virtual"},@t{"2s"}),ev);

  @b{while}(@b{true}) series->@b{tick}();
@end example
@caption{Program using the scheduler to set gain to 0 after two seconds.}
@end float

@subsubsection Repeating Events
We can repeat events using the event @code{set_repeat} method of the event. This
method takes a @code{Repeat} value which is essentially a (rate,count) tuple. In
the example below, two events are posted. One sets the volume to 0, the other to
1. By staggering their dispatch we can achieve a gating effect. Here we repeat
the events forever by specifying the repeat rate only as in @code{Repeat("1s")}.
To specify a finite repeat count we could set the repeat count to five as in
@code{Repeat("1s",5)}. Gaze wonderously at the example.

@float Figure,fig:sch2
@example
  MarSystemManager mng;

  MarSystem* series = mng.@b{create}(@t{"Series"}, @t{"series"});
  series->@b{addMarSystem}(mng.@b{create}(@t{"SineSource"}, @t{"src"}));
  series->@b{addMarSystem}(mng.@b{create}(@t{"Gain"}, @t{"g"}));
  series->@b{addMarSystem}(mng.@b{create}(@t{"AudioSink"}, @t{"snk"}));

  series->@b{updctrl}(@t{"AudioSink/snk/mrs_bool/initAudio"}, @b{true});
  series->@b{updctrl}(@t{"SineSource/src/mrs_real/frequency"},440.0);
  series->@b{updctrl}(@t{"Gain/g/mrs_real/gain"},1.0);

  EvValUpd* ev_off = @b{new} @b{EvValUpd}(series,@t{"Gain/g/mrs_real/gain"},0.0);
  ev_off->@b{set_repeat}(@b{Repeat}(@t{"1s"})); @i{// repeat forever}
  @i{//ev_off->set_repeat(Repeat("1s",4)); // repeat four times}

  EvValUpd* ev_on = @b{new} @b{EvValUpd}(series,@t{"Gain/g/mrs_real/gain"},1.0);
  ev_on->@b{set_repeat}(@b{Repeat}(@t{"1s"}));

  @i{// stagger the dispatch of the events, off by 1 second}
  series->@b{updctrl}(@b{TmTime}(@t{"TmSampleCount/Virtual"},@t{"1s"}),ev_off);
  series->@b{updctrl}(@b{TmTime}(@t{"TmSampleCount/Virtual"},@t{"2s"}),ev_on);

  @b{while}(@b{true}) series->@b{tick}();
@end example
@caption{Program using two events that toggle the gain between 0 and 1 every second.}
@end float

But how does this work under the hood, uhh, so to speak, you ask. For a pending
event (whose time is now), the scheduler will remove it from the queue, call its
dispatch method, check whether it should be repeated by calling its @code{repeat}
method. If it is to be repeated, the rate will be read by calling the
@code{repeat_interval()} method which reads the rate from the @code{Repeat}
value originally supplied through the @code{set_repeat} method. A calculation of
the next dispatch time is made and the event is reposted to the queue. See the
@code{void TmTimer::dispatch()} method of @file{TmTimer.cpp} for the exact
method.

@node Writing a new Timer
@subsection Writing a new Timer

Timers control the scheduling of events with respect to some control rate. When
writing new timers we don't want to have to worry about this scheduling
activity. Instead we wish to define new control rates. No problem. All we have
to do is inherit from the TmTimer class. For lack of a more creative idea this
section will explain a slightly modified TmSampleCount timer.

When creating new timers we first create a class that inherits from TmTimer.
This class is placed in the src/marsyas directory and added to the build
system. Our example, requires a constructor that takes a MarSystem to read the
time from. Our timer will read the "mrs_natural/onSamples" control to find out
how long the interval of time is, in samples, between successive ticks. This
will be used to advance our timer. On construction we call setReadCtrl which
gets the control as a MarControlPtr for faster access than calling getctrl on
each tick.

Whenever the scheduler is ticked, it will tick each of the timers it controls.
These timers will call their @code{readTimerSrc()} method to advance their
clocks. Our @code{readTimerSrc} method will read the onSamples control and
return this value (elapsed time since last tick). Our timer is now operational.

Timers may also require the definition of special time units. In the case of
real time we may want to define what milliseconds or seconds mean with respect
to sample count. To do this we must override the
@code{mrs_natural intervalsize(string interval)} method. For our timer, we will
simply call the static method @code{time2samples(string)} defined in
@file{Conversions} and pass it the string and the current sample rate. Now our
timer supports time defined in samples, microseconds, milliseconds, seconds,
minutes, and hours.

@float Figure,fig:sch3
@example
@b{#ifndef} MARSYAS_TM_SAMPLE_COUNT_H
@b{#define} MARSYAS_TM_SAMPLE_COUNT_H

@b{#include} @t{"TmTimer.h"}
@b{#include} @t{"MarControlValue.h"}
@b{#include} @t{"MarSystem.h"} 

@b{namespace} Marsyas
@{
  @i{// forward declaration of MarSystem allows Scheduler.getctrl("insamples")}
  @i{// for scheduler count}
  @b{class} MarSystem; @i{// forward declaration}

  @b{class} TmSampleCount : @b{public} TmTimer @{
  @b{protected}:
    MarSystem* read_src_;
    MarControlPtr read_ctrl_;

  @b{public}:
    @i{// Constructors }
    @b{TmSampleCount}(MarSystem*);
    @b{TmSampleCount}(@b{const} TmSampleCount& s);
    @b{virtual} ~@b{TmSampleCount}();
    TmTimer* @b{clone}();

    void @b{setReadCtrl}(MarSystem* ms);
    mrs_natural @b{readTimeSrc}();
    mrs_natural @b{intervalsize}(std::string interval);

    @b{virtual} void @b{updtimer}(std::string cname, TmControlValue value);
@};

@}@i{//namespace Marsyas}

@b{#endif}

@end example
@caption{TmSampleCount header file example.}
@end float

@float Figure,fig:sch4
@example
@b{#include} @t{"TmSampleCount.h"}
@b{#include} @t{"MarSystem.h"}
@b{#include} @t{"Scheduler.h"}

@b{using} @b{namespace} std;
@b{using} @b{namespace} Marsyas;

TmSampleCount::@b{TmSampleCount}(MarSystem* ms) : @b{TmTimer}(@t{"TmSampleCount"},@t{"Virtual"})
@{
    @b{setReadCtrl}(ms);
@}
TmSampleCount::@b{TmSampleCount}(@b{const} TmSampleCount& s) : @b{TmTimer}(s)
@{
    @b{setReadCtrl}(s.read_src_);
@}
TmSampleCount::~@b{TmSampleCount}()@{ @}

TmTimer* TmSampleCount::@b{clone}()
@{ 
  @b{return} @b{new} @b{TmSampleCount}(*@b{this}); 
@}
void TmSampleCount::@b{setReadCtrl}(MarSystem* ms)
@{
    read_src_=ms;
    @b{if} (read_src_!=NULL) read_ctrl_=read_src_->@b{getctrl}(@t{"mrs_natural/onSamples"});
@}

mrs_natural TmSampleCount::@b{readTimeSrc}()
@{
    @b{if} (read_src_==NULL) @{
        @b{MRSWARN}(@t{"TmSampleCount::readTimeSrc()  time source is NULL"});
        @b{return} 0;
    @}
    mrs_natural m = read_ctrl_->to<mrs_natural>();
    @b{return} m;
@}
mrs_natural TmSampleCount::@b{intervalsize}(string interval)
@{
    @b{return} (read_src_==NULL) ? 0 : @b{time2samples}(interval,read_src_->@b{getctrl}(@t{"mrs_real/israte"})->to<mrs_real>());
@}
void
TmSampleCount::@b{updtimer}(std::string cname, TmControlValue value)
@{
    bool type_error=@b{false};
    @b{if} (cname==@t{"MarSystem/source"}) @{
        @b{if} (value.@b{getType}()==tmcv_marsystem) @{ @b{setReadCtrl}(value.@b{toMarSystem}()); @}
        @b{else} type_error=@b{true};
    @}
    @b{else}
        @b{MRSWARN}(@t{"TmSampleCount::updtimer(string,TmControlValue)  unsupported control"});
    @b{if} (type_error)
        @b{MRSWARN}(@t{"TmSampleCount::updtimer(string,TmControlValue)  wrong type to "}+cname);
@}
@end example
@caption{TmSampleCount C++ source file example.}
@end float

@subsubsection Updating timers at run-time
The TmTimer class also supports communication through the updtimer method. An
example of this is shown in the TmSampleCount timer above. This
is not necessary for the operation of our timer but we might want to support the
changing of timer parameters at run-time through the updtimer interface. To do
this we simply override the
@code{void updtimer(std::string cname, TmControlValue value)} method. We can
now parse the supplied timer control path and set the appropriate value.

Timer control paths have the same format as MarSystem controls. For example, our
timer could be accessed through:
@float Figure,fig:sch5
@example
marsys->@b{updtimer}(@t{"TmSampleCount/Virtual/MarSystem/source"},marsys);
@end example
@caption{Setting timer parameters using the updtimer call.}
@end float

The TmControlValue defines the allowable values that may be passed to timers.
These values are limited to:
@code{float, double, int, long, std::string, const char*, bool, MarSystem*}.
However, one could always modify the TmControlValue class to add additional
types. Be careful of values clashing such as NULL pointers and the integer
value 0.

@subsubsection Timer Factory
@anchor{archtmrfac} 
New timers can be added to the Timer Factory by modifying
@file{TmTimerManager}. Doing so allows the use of the addTimer method in
@file{MarSystem} by simply specifying the type/name of the timer as
opposed to creating a new timer.

@float Figure,fig:sch6
@example
net->@b{addTimer}(@t{"TmSampleCount"},@t{"counter"});
@end example
@caption{Adding a new timer to MarSystem net using the timer factory.}
@end float

The instructions for adding new timers to the factory are contained in
@file{TmTimerManager} and repeated here. Basically, a map is created
from "TimerName"=>TimerConstructorObject. This makes it possible to use
a map for fast access to specific timers and it prevents having to
instantiate each Timer type at startup. The constructor object simply
wraps the new operator so that it constructs objects only when
requested.

@itemize
@item Add the timer's header file to the top of @file{TmTimerManager.cpp} as an #include.
@item Underneath the includes, wrap the timer name in the macro @code{TimerCreateWrapper}.
@item In the addTimers function wrap the timer name in the macro @code{registerTimer}.
@end itemize

@node Writing a new Event
@subsection Writing a new Event

Suppose we want to fade the volume down to silence using a Gain MarSystem. We
could accomplish this using the scheduler and several EvValUpd events. Assuming
the gain control is at 1.0 to begin we just issue 10 EvValUpd events each with
a progressively lower volume amount: 0.9, 0.8, 0.7, ... and each at a time that
is a little bit later than the previous. This is messy and repetitive. Why not
make a new event, called EvRampCtrl, that encapsulates this behaviour.

We start by defining a new EvRampCtrl class that inherits from the @file{EvEvent}
class. We define a constructor that takes a MarSystem to act upon, a control
to modify, a starting value, an ending value, and a step amount. The implicit
assumption is that this event will only work on values of type @code{mrs_real}
so that values we supply must all be of the correct type. The header and cpp
files are supplied below.

We will need an additional variable to save the current adjustment value. Also,
the event will need to repeat so we will maintain a repeat flag that is true
until we pass the end value. We override the @code{repeat()} method of
@file{EvEvent} to return the current value of the repeat flag. The required
variables are shown in the header file below.

@float Figure,fig:sch7
@example
@b{#ifndef} MARSYAS_EV_RAMPCTRL_H
@b{#define} MARSYAS_EV_RAMPCTRL_H

@b{#include} @t{<string>}

@b{#include} @t{"MarControl.h"}
@b{#include} @t{"EvEvent.h"}
@b{#include} @t{"TmControlValue.h"}

@b{namespace} Marsyas
@{
  @b{class} MarSystem; @i{// forward declaration}

  @b{class} EvRampCtrl : @b{public} EvEvent @{
  @b{protected}:
    MarSystem* target_;
    std::string cname_;
    double start_, end_, value_, rate_;
    bool repeat_flag_;

  @b{public}:
    @i{// Constructors}
    @b{EvRampCtrl}(MarSystem* m, std::string cname, double start, double end, double rate);
    @b{EvRampCtrl}(EvRampCtrl& e);
    @b{virtual} ~@b{EvRampCtrl}();

    @b{virtual} EvRampCtrl* @b{clone}();

    @i{// Set/Get methods}
    void @b{set}(MarSystem* ms, std::string cname, double s, double e, double r);

    bool @b{repeat}() @{ @b{return} repeat_flag_; @};

    @i{// Event dispatch}
    void @b{dispatch}();

  @};

@}@i{//namespace Marsyas}

@b{#endif}

@end example
@caption{EvRampCtrl event header file example.}
@end float

@float Figure,fig:sch77
@example
@b{#ifndef} MARSYAS_EV_RAMPCTRL_H
@b{#define} MARSYAS_EV_RAMPCTRL_H

@b{#include} @t{<string>}

@b{#include} @t{"MarControl.h"}
@b{#include} @t{"EvEvent.h"}
@b{#include} @t{"TmControlValue.h"}

@b{namespace} Marsyas
@{
  @b{class} MarSystem; @i{// forward declaration}

  @b{class} EvRampCtrl : @b{public} EvEvent @{
  @b{protected}:
    MarSystem* target_;
    std::string cname_;
    double start_, end_, value_, rate_;
    bool repeat_flag_;

  @b{public}:
    @i{// Constructors}
    @b{EvRampCtrl}(MarSystem* m, std::string cname, double start, double end, double rate);
    @b{EvRampCtrl}(EvRampCtrl& e);
    @b{virtual} ~@b{EvRampCtrl}();

    @b{virtual} EvRampCtrl* @b{clone}();

    @i{// Set/Get methods}
    void @b{set}(MarSystem* ms, std::string cname, double s, double e, double r);

    bool @b{repeat}() @{ @b{return} repeat_flag_; @};

    @i{// Event dispatch}
    void @b{dispatch}();

  @};

@}@i{//namespace Marsyas}

@b{#endif}
@end example
@caption{EvRampCtrl event header file example.}
@end float

@c @end example



The main logic for our event is contained in the dispatch method. Basically, we
check to see if we have passed the end value during ramping and if so set the
repeat flag to false. The next time that the scheduler checks to see if the
event repeats the scheduler will read the false value and delete the event. If
we have not passed the end value then we set the specified control to the
current ramp value and decrement the current value by the ramp amount. The
scheduler will see that the event is to be repeated, it will read the repeat
rate amount, and repost the event to the queue.

@float Figure,fig:sch8
@c Generator: GNU source-highlight, by Lorenzo Bettini, http://www.gnu.org/software/src-highlite
@example
@b{#include} @t{"EvRampCtrl.h"}
@b{#include} @t{"MarSystem.h"}

@b{using} @b{namespace} std;
@b{using} @b{namespace} Marsyas;

EvRampCtrl::@b{EvRampCtrl}(MarSystem* m, std::string cname, double start, double end, double rate) : @b{EvEvent}(@t{"EvRampCtrl"},@t{"rc"})
@{
    @b{set}(m,cname,start,end,rate);
@}
EvRampCtrl::@b{EvRampCtrl}(EvRampCtrl& e) : @b{EvEvent}(@t{"EvRampCtrl"},@t{"rc"})
@{
    @b{set}(e.target_,e.cname_,e.start_,e.end_,e.rate_);
@}

EvRampCtrl::~@b{EvRampCtrl}() @{ @}

EvRampCtrl*
EvRampCtrl::@b{clone}() @{ @b{return} @b{new} @b{EvRampCtrl}(*@b{this}); @}

void
EvRampCtrl::@b{set}(MarSystem* ms, string cname, double start, double end, double rate)
@{
    target_=ms; cname_=cname;
    start_=start; end_=end; rate_=rate;
    value_=start_; repeat_flag_=@b{true};
@}

void
EvRampCtrl::@b{dispatch}()
@{
    @b{if} (target_ !=NULL) @{
      cout << @t{"target_->updctrl("} << cname_ << @t{", "} << value_ << @t{")}@t{\n}@t{"};
      @b{if}(value_<end_) repeat_flag_=@b{false};
      @b{else} @{
        target_->@b{updctrl}(cname_,value_);
        value_ = value_ - rate_;
      @}
    @}
@}


@end example
@caption{EvRampCtrl event C++ source file example.}
@end float

The @code{fade1} method shows our EvRampCtrl event in action. We set the repeat
rate of the event to 0.2 seconds.

@c @float Figure,fig:sch9
@c @verbatim
@float Figure, fig:sch9
@c Generator: GNU source-highlight, by Lorenzo Bettini, http://www.gnu.org/software/src-highlite
@example
void @b{fade1}() @{
  MarSystemManager mng;

  MarSystem* series = mng.@b{create}(@t{"Series"}, @t{"series"});
  series->@b{addMarSystem}(mng.@b{create}(@t{"SineSource"}, @t{"src"}));
  MarSystem* gain = mng.@b{create}(@t{"Gain"}, @t{"g"});
  series->@b{addMarSystem}(gain);
  series->@b{addMarSystem}(mng.@b{create}(@t{"AudioSink"}, @t{"snk"}));
  series->@b{updctrl}(@t{"AudioSink/snk/mrs_bool/initAudio"}, @b{true});
  series->@b{updctrl}(@t{"SineSource/src/mrs_real/frequency"},440.0);
  series->@b{updctrl}(@t{"Gain/g/mrs_real/gain"},1.0);

  EvRampCtrl* ev = @b{new} @b{EvRampCtrl}(gain,@t{"mrs_real/gain"},1.0,0.0,0.05);
  ev->@b{set_repeat}(@b{Repeat}(@t{"0.2s"}));
  
  series->@b{updctrl}(@b{TmTime}(@t{"TmSampleCount/Virtual"},@t{"2s"}),ev);

  @b{while}(@b{true}) @{
    series->@b{tick}();
  @}
@}
@end example
@caption{Program using the EvRampCtrl example event.}
@end float
@c @caption{Program using the EvRampCtrl example event.}
@c @end float

@subsubsection Expression Events
For a large number of events there is commonality. The Expression syntax
was developed to allow the creation of events without having to code
new custom event classes. In order to accomplish this there is a built
in compiler for the syntax that is invoked when supplying the expression
as a string to the @file{Ex} class.

@float Figure, figsch10
@c Generator: GNU source-highlight, by Lorenzo Bettini, http://www.gnu.org/software/src-highlite
@example
@b{#include} @t{<stdio.h>}
@b{#include} @t{"MarSystemManager.h"}
@b{#include} @t{"EvExpr.h"}

@b{using} @b{namespace} std;
@b{using} @b{namespace} Marsyas;

void @b{sched1}() @{
  MarSystemManager mng;

  MarSystem* fanin = mng.@b{create}(@t{"Fanin"}, @t{"fanin"});
  fanin->@b{addMarSystem}(mng.@b{create}(@t{"SineSource"}, @t{"src1"}));
  fanin->@b{addMarSystem}(mng.@b{create}(@t{"SineSource"}, @t{"src2"}));
  fanin->@b{updctrl}(@t{"SineSource/src1/mrs_real/frequency"},3000.0);
  fanin->@b{updctrl}(@t{"SineSource/src2/mrs_real/frequency"},1000.0);

  MarSystem* series = mng.@b{create}(@t{"Series"}, @t{"series"});
  series->@b{addMarSystem}(fanin);

  series->@b{addMarSystem}(mng.@b{create}(@t{"AudioSink"}, @t{"dest"}));
  series->@b{updctrl}(@t{"AudioSink/dest/mrs_bool/initAudio"}, @b{true});

@b{#if} 0
  @i{// using aliases makes this a little more readable, see the next bit}
  EvExpr* e = @b{new} @b{EvExpr}(series,
    @b{Ex}(@t{"Fanin/fanin/SineSource/src1/mrs_real/frequency << 120. + 3000. * R.rand(), \}
@t{        Fanin/fanin/SineSource/src2/mrs_real/frequency << 120. + 800. * R.rand(),"}
       @t{"'src1='+Fanin/fanin/SineSource/src1/mrs_real/frequency+ \}
@t{        ' src2='+Fanin/fanin/SineSource/src2/mrs_real/frequency+'}@t{\n}@t{'>>Stream.op"}),
    @b{Rp}(@t{"true"}));

@b{#else}
  EvExpr* e = @b{new} @b{EvExpr}(series,
        @i{// First line to Ex will be the init expression, run once, when event is posted}
    @b{Ex}(@t{"Fanin/fanin/SineSource/src1/mrs_real/frequency >> @@freq1, \}
@t{        Fanin/fanin/SineSource/src2/mrs_real/frequency >> @@freq2 "},
       @i{// Second line to Ex is the expression, repeated each time the event is posted}
       @t{"freq1 << 120. + 3000. * R.rand(),\}
@t{        freq2 << 120. + 800. * R.rand(),\}
@t{        'src1=' + freq1 + ' src2=' + freq2 + '}@t{\n}@t{' >> Stream.op"}),
    @b{Rp}(@t{"true"}));
@b{#endif}

  @i{// set event to repeat every 1/4 second}
  e->@b{set_repeat}(@b{Repeat}(@t{"0.25s"}));
  @i{// post the event}
  series->@b{updctrl}(@b{TmTime}(@t{"TmSampleCount/Virtual"},@t{"0s"}), e);

  @b{while}(@b{true}) series->@b{tick}();

  @b{delete} series;
@}
@end example
@caption{Random sine waves using the Expression syntax.}
@end float



































































@node Marsyas Expression Syntax
@subsection Marsyas Expression Syntax
Expressing instantaneous change in Marsyas.

@menu
* Type System::
* Operators::
* Variables::
* Assignment::
* Links::
* Conditional Statements::
* Multiple Expressions::
* Properties::
* Sequences::
* Function Libraries::
* Using::
* Extending::
* Marsyas Expression Examples::
@end menu
@c * Operators::
@c * Variables
@c * Assignment::
@c * Links::
@c * Conditional Statements::
@c * Multiple Expressions::
@c * Properties::
@c * Lists::
@c * Function Libraries::
@c * Using::
@c * Extending::

Still in development, but what software project isn't..

The motivation for an expression syntax within the scheduler is purely
one of convenience. While the Marsyas scheduler is highly configurable,
allowing the programmer to add their own classes for their own event
requirements, eyes tend to glaze over when C++ programming is mentioned.
This expression syntax allows a programmer to define an expression that
can be fed to an event and evaluated once or any number of times within
the scheduler. While many functions are available, more can be added
with a little ... C++ programming. Read on fearless marsyasian.

@node Type System
@subsubsection Type System

@itemize
@item Basic Types
  @itemize
  @item Bool - can be true and false or shorthand $t and $f.
  @item Natural - a number without a decimal point.
  @item Real - floating point number (equivalent of a C double) can be written with leading or trailing decimal point - .123, 123., and 123.456.
  @item String - a string of characters delimeted by single quotes - 'hello' - which may contain newline \n or tab \t characters - '1\t2\t3\n'. Strings are also sequence types and can be modified using the sequence iterators.
  @end itemize

@item Type coercion

There are a few instances where type coercion may take place. Binary operators such as + require two values of the same type. Natural numbers are therefore promoted to reals in such a situation (1 + 1.0 := ((real)1) + 1.0). Real numbers are not converted to naturals in any case. For string concatenation using the + operator, any type concatenated to a string is converted to a string type (1+'2' := '12').

Type coercion also affects function parameters. For instance, the function Real.cos(real) when used as Real.cos(1) would result in a type error as 1 is interpreted to be a natural value. Instead the function call is converted to Real.cos((real)1).

Note that there is a performance penalty for coercion as slight as it may be.

@item Type terms used in this document
  @itemize
  @item bool
  @item natural
  @item real
  @item string
  @item num_t := natural | real
  @item basic_t := natural | real | string | bool
  @end itemize
@end itemize

@node Operators
@subsubsection Operators

@itemize
@item String
  @itemize
  @item Binary ( + )
    @itemize
    @item Concatenation (+).
      @itemize
      @item string + basic_t := string ~ 'go ' + 2 := 'go 2'
      @item basic_t + string := string ~ 2 + ' much' := '2 much'
      @item string + string := string ~ 'too' + ' much' := 'too much'
      @end itemize
    @end itemize
  @end itemize
@item Numbers
  @itemize
  @item Unary ( - )
    @itemize
    @item Negation (-) - overloaded for Real, Natural.
      @itemize
      @item - natural := natural ~ - 2 := -4
      @item - real := real ~ - 2.1 := -2.1
      @end itemize
    @end itemize
  @item Binary ( + - * / % )@*
    Operations involving both a Real and Natural type will result in a Real type.
    @itemize
    @item Addition (+) - overloaded for Real, Natural, and String types.
      @itemize
      @item natural + natural := natural ~ 2 + 2 := 4
      @item num_t + real := real ~ 2 + 2.3 := 4.3
      @item real + num_t := real ~ 2.3 + 2 := 4.3
      @item string + basic_t := string ~ 'go ' + 2 := 'go 2'
      @item basic_t + string := string ~ 2 + ' much' := '2 much'
      @end itemize
    @item Subtraction (-) - overloaded for Real and Natural types.
      @itemize
      @item natural - natural := natural ~ 2 - 2 := 0
      @item num_t - real := real ~ 2 - 2.3 := 0.3
      @item real - num_t := real ~ 2.3 - 2 := 0.3
      @end itemize
    @item Multiplication (*) - overloaded for Real and Natural types.
      @itemize
      @item natural * natural := natural ~ 2 * 2 := 4
      @item num_t * real := real ~ 2 * 2.3 := 4.6
      @item real * num_t := real ~ 2.3 * 2 := 4.6
      @end itemize
    @item Division (/) - overloaded for Real and Natural types.@*
      The division operator is also used to delimit control name paths
      so this a/b or will be interpreted as a path and a /b will be
      interpreted as variable a followed by path /b. Division involving
      variables must be written with the division separated by spaces as
      in: a / b or even a/ b.
      @itemize
      @item natural / natural := natural ~ 2 / 2 := 1
      @item num_t / real := real ~ 2 / 2.3 := 0.8695
      @item real / num_t := real ~ 2.3 / 2 := 1.15
      @end itemize
    @item Remainder (%) - overloaded for Real and Natural types.
      @itemize
      @item natural % natural := natural ~ 3 % 2 := 1
      @item num_t % real := real ~ 4 % 1.5 := 1.0
      @item real % num_t := real ~ 4.5 % 2 := 0.5
      @end itemize
    @end itemize
  @end itemize
@item Boolean
  @itemize
  @item Negation ( ! )
    @itemize
    @item ! bool := bool ~ ! $t := $f
    @end itemize
  @item Relational ( & | )
    @itemize
    @item And (&) - comparison of bool types.
      @itemize
      @item bool & bool := bool ~ $t & $f := $t
      @end itemize
    @item Or (|) - comparison of bool types.
      @itemize
      @item bool | bool := bool ~ $t | $f := $t
      @end itemize
    @end itemize
  @item Comparison ( = != > >= < <= )@*
  Comparisons may only be made between the same types.
    @itemize
    @item Equal (=) - comparison of types.
      @itemize
      @item basic_t = basic_t := bool ~ 3 = 2.1 := $f
      @end itemize
    @item Not Equal (!=) - comparison of types.
      @itemize
      @item basic_t != basic_t := bool ~ 3 != 2.1 := $t
      @end itemize
    @item Greater Than (>) - comparison of types.
      @itemize
      @item basic_t > basic_t := bool ~ 3 > 2.1 := $t
      @end itemize
    @item Greater Equal (>=) - comparison of types.
      @itemize
      @item basic_t >= basic_t := bool ~ 3 >= 2.1 := $t
      @end itemize
    @item Less Than (<) - comparison of types.
      @itemize
      @item basic_t < basic_t := bool ~ 3 < 2.1 := $f
      @end itemize
    @item Less Equal (<=) - comparison of types.
      @itemize
      @item basic_t <= basic_t := bool ~ 3 <= 2.1 := $f
      @end itemize
    @end itemize
  @end itemize
@end itemize


@node Variables
@subsubsection Variables

Variable names must start with a letter but may be followed by letters
or numbers. hello and hi8 are valid names wheras 2much is not. The type
of a variable is defined through assignment. 12 >> x defines variable x
of type natural. Once a variable type is defined it cannot be changed,
12 >> x, 'hello' >> x results in a type mismatch error. There is no
notion of scope except that all variables are in the same scope so that
variables defined within a conditional statement will exist outside the
conditional and after it has been evaluated.

@strong{Control Names ( /absolute/path or relative/path )}

Control names are written using the path notation,
/Gain/gain/mrs_real/gain.

@strong{Aliases ( @@name )}

Control names can be rather long. Aliases can be used to shorten
expressions containing control names. Making an alias is done through
assignment to a name preceded by the @ symbol: /Gain/gain/mrs_real/gain
>> @@gain. After assignment, the alias can be used as any other variable
name: gain << 0.5.

@node Assignment
@subsubsection Assignment ( << >> )

Assignment is performed using the assignment operators. Left assignment
x << 5 and right assignment 5 >> x. These operators are equivalent.
Assignment of a value to a variable defines the variable type. Once a
variable is 'typed' it cannot be assigned another type. Note there is no
scope, all variables are at the 'top level.'

@strong{Assignment Sugar ( <<+ +>> etc... )}

Note: left and right assignment do not necessarily yield the same
results.

@itemize
@item Add Assign ( <<+, +>> ) - left assignment is x <<+ 5 is x << x + 5 whereas right assignment is 5 +>> x is 5 + x >> x.
@item Subtract Assign ( <<-, ->> ) - left assignment is x <<- 5 is x << x - 5 whereas right assignment is 5 ->> x is 5 - x >> x. Left and right assignment are not the same here.
@item Multiply Assign ( <<*, *>> ) - left assignment is x <<* 5 is x << x * 5 whereas right assignment is 5 *>> x is 5 * x >> x.
@item Divide Assign ( <</, />> ) - left assignment is x <</ 5 is x << x / 5 whereas right assignment is 5 />> x is 5 / x >> x. Left and right assignment are not the same here.
@item Remainder Assign ( <<%, %>> ) - left assignment is x <<% 5 is x << x % 5 whereas right assignment is 5 %>> x is 5 % x >> x. Left and right assignment are not the same here.
@end itemize

@node Links
@subsubsection Links ( -> <- )

Controls may be linked using the link operators. Left and right
operators perform the same actions. There is no bidirectional link since
this would require defining a link order. This order is left to the user
who will have to explicity define the order by making two links.

@node Conditional Statements
@subsubsection Conditional Statements ( @{? cond_expr : exprs1 : exprs2 @} )

The conditional statement is used for making decisions. The cond term is
the decision and must result in a boolean. If cond is true then the
then_expr is executed otherwise the else_expr is executed. Each of these
expressions may be a list of expressions, even the cond_expr so long as
cond_expr results in a bool type and both expr1 and expr2 result in the
same type. Example: @{? 5<3 : 1 : 2@}.

@node Multiple Expressions
@subsubsection Multiple Expressions ( exprs := expr1 , expr2 , expr3 )

Multiple expressions may be executed by separating them with commas as
in t << 5, t << t - 2.

@node Properties
@subsubsection Properties ( ie Real.pi or 'hello'.2 etc. )

Properties are simply a way of associating methods or values with types.
As an example, the String module supports a number of methods that can
accessed using the property notation. The expression String.len('hello')
results in the natural value of 5. This expression could also be written
as 'hello'.len() since the value 'hello' is known to be a string. This
is just sugar for String.len('hello'). Here the first parameter to
String.len is filled with the value. This can be used for variables of
the right type as in s << 'hello', s.len() is similar to the previous
except that variable s is defined.

All basic types or things that evaluate to basic types can respond to
property calls. For example the conditional operator
@{?cond:expr1:expr2@} evaluates to a single type so can take on a
property as in @{?true:'123':'12'@}.len. To take this further a function
call resulting in a basic type can take on properties as well and so on:
'123'.len.max(4).

@node Sequences
@subsubsection Sequences (Lists)

Sequence types are those data types that have a sequence of elements.
Falling into this category are lists and strings not natural or real
numbers.

Lists are denoted using the square brackets as in [ 1, 2, 3 ]. Lists can
contain other lists as in [ [1,2], [3,4] ]. However, all elements of a
list must be of the same type. This [ 1, '2'] and this [ 1, [ 2, 3 ] ]
are not valid lists.

@strong{Iterators}

There are four different iterators for working with sequence types:
map, iter, for, rfor. There are subtle differences.

@itemize
@item map @{map x in xs: <expr>@}@*
The map iterator works in a similar fashion to the functional map. Map
iterates from left to right across each element and replaces each
element with a new one of the same or different type. Map returns a new
list without modifying the original. An example: xs<<[1,2,3],
b<<@{map x in xs: x+1@}.

@item iter @{iter x in xs: <expr>@}@*

The iter iterator works like map except that it modifies the original
list in place. Iter returns unit. An example: xs<<[1,2,3],
@{iter x in xs: x+1@}.

@item for @{for x in xs: <expr>@}@*

The for iterator iterates across the list but does not modify the
original list and does not create a new list. for returns unit. An
example: xs<<[1,2,3], sum<<0, @{for x in xs: sum <<+ x@}.

@item rfor @{rfor x in xs: <expr>@}@*

The rfor iterator works in the same way as for but from right to left.
An example: xs<<[1,2,3], b<<@{rfor x in xs: Stream.opn << x@}.
@end itemize

@strong{Element Access}@*

Elements of sequences may be accessed using the standard array notation
as in a<<[1,2,3], one<<a[0], three<<a[2]. Note that the first element is
position 0. Don't let me catch you using an index that's too big.

@strong{Slices}@*

Slices are portions of sequences. A range takes two positions in the
list - start position (included) and end position (not included)
separated by a colon [start:end]. If the start position is left out then
the first element is assumed. If the last element is left out then the
end is assumed. The start and end positions may be adjusted to avoid
errors, ie negative start becomes the beginning of the list.

We can take the head and tail of a list using slices: a<<[1,2,3],
hd<<a[0], tl<<a[1:].

@strong{Concatenation, Joining}@*

Sequences may be joined using the concatentation operator otherwise
known as +. [1,2,3]+[4] joins the two lists into [1,2,3,4].

@node Function Libraries
@subsubsection Function Libraries

In most cases library names can be shortened to reduce typing. For
example the Real module can be reduced to R as in R.cos(1.57).

@itemize
@item Real (R)
  @itemize
  @item @b{mrs_real} @i{Real}.e @* e = ~2.718281828
  @item @b{mrs_real} @i{Real}.pi @* pi = ~3.141592654
  @item @b{mrs_real} @i{Real}.pi2 @* pi/2 = ~1.570796327
  @item @b{mrs_real} @i{Real}.pi4 @* pi/4 = ~0.785398163
  @item @b{mrs_real} @i{Real}.rpd @* Radians per Degree = ~0.017453292
  @item @b{mrs_real} @i{Real}.dpr @* Degrees per Radian = ~57.29577951
  @item @b{mrs_real} @i{Real}.sqrt2 @* Square Root of 2 = ~1.414213562
  @item @b{mrs_real} @i{Real}.cos(@b{mrs_real}) @* Trigonometric cosine in radians.
  @item @b{mrs_real} @i{Real}.acos(@b{mrs_real}) @* Trigonometric arc cosine in radians.
  @item @b{mrs_real} @i{Real}.cosh(@b{mrs_real}) @* Hyperbolic cosine in radians.
  @item @b{mrs_real} @i{Real}.sin(@b{mrs_real}) @* Trigonometric sine in radians.
  @item @b{mrs_real} @i{Real}.asin(@b{mrs_real}) @* Trigonometric arc sine in radians.
  @item @b{mrs_real} @i{Real}.sinh(@b{mrs_real}) @* Hyperbolic cosine in radians.
  @item @b{mrs_real} @i{Real}.tan(@b{mrs_real}) @* Trigonometric tangent in radians.
  @item @b{mrs_real} @i{Real}.atan(@b{mrs_real}) @* Trigonometric arc tangent in radians.
  @item @b{mrs_real} @i{Real}.ln(@b{mrs_real}), @b{mrs_real} @i{Real}.log(@b{mrs_real}) @* Natural logarithm, base e.
  @item @b{mrs_real} @i{Real}.log2(@b{mrs_real}) @* Logarithm base 2.
  @item @b{mrs_real} @i{Real}.log10(@b{mrs_real}) @* Logarithm base 10.
  @item @b{mrs_real} @i{Real}.sqrt(@b{mrs_real}) @* Square root.
  @end itemize
@item Natural (N)
  @itemize
  @item @b{mrs_natural} @i{Natural}.randmax @* Constant for the maximum random number.
  @item @b{mrs_natural} @i{Natural}.abs(@b{mrs_natural}) @* Absolute value.
  @item @b{mrs_natural} @i{Natural}.rand() @* Generate a random number.
  @item @b{mrs_natural} @i{Natural}.srand(@b{mrs_natural}) @* Generate a random number using the given seed.
  @item @b{mrs_natural} @i{Natural}.min(@b{mrs_natural}, @b{mrs_natural}) @* Return the minimum of two numbers.
  @item @b{mrs_natural} @i{Natural}.max(@b{mrs_natural}, @b{mrs_natural}) @* Return the maximum of two numbers.
  @end itemize
@item String (S)
  @itemize
  @item @b{mrs_natural} @i{String}.len(@b{mrs_string}) @* String length.
  @end itemize
@item Stream
  @itemize
  @item @b{outstream} op @* Stream.op and Stream.opn support assignment. Data can be written to stdout by assigning to this object as in 3.1415 >> Stream.op or 'hello' >> Stream.op.
  @item @b{outstream} @i{Stream}.op(@b{mrs_real}) @* write a mrs_real number to stdout.
  @item @b{outstream} @i{Stream}.op(@b{mrs_natural}) @* write a mrs_natural number to stdout.
  @item @b{outstream} @i{Stream}.op(@b{mrs_bool}) @* write a mrs_bool number to stdout.
  @item @b{outstream} @i{Stream}.op(@b{mrs_string}) @* write a mrs_string number to stdout.
  @item @b{outstream} @i{Stream}.opn(@b{mrs_real}) @* write a mrs_real number to stdout followed by a newline.
  @item @b{outstream} @i{Stream}.opn(@b{mrs_natural}) @* write a mrs_natural number to stdout followed by a newline.
  @item @b{outstream} @i{Stream}.opn(@b{mrs_bool}) @* write a mrs_bool number to stdout followed by a newline.
  @item @b{outstream} @i{Stream}.opn(@b{mrs_string}) @* write a mrs_string number to stdout followed by a newline.
  @end itemize
@item Timer (Tmr)
  @itemize
  @item @b{mrs_timer} @i{Timer}.cur @* the current timer that the event expression is posted on.
  @item @b{mrs_string} @i{Timer}.name(@b{mrs_timer}) @* the name of the timer
  @item @b{mrs_string} @i{Timer}.type(@b{mrs_timer}) @* the type of the timer
  @item @b{mrs_string} @i{Timer}.prefix(@b{mrs_timer}) @* the prefix of the timer which is type/name
  @item @b{mrs_natural} @i{Timer}.time(@b{mrs_timer}) @* returns the current time of the timer as a count. This is not in the form of the specific representation for the particular timer.
  @item @b{mrs_bool} @i{Timer}.upd(@b{mrs_timer}, @b{mrs_string}, @b{mrs_bool}) @* updates a timer control value where the second parameter is the string path and the third parameter is the value
  @item @b{mrs_bool} @i{Timer}.upd(@b{mrs_timer}, @b{mrs_string}, @b{mrs_real}) @* updates a timer control value where the second parameter is the string path and the third parameter is the value
  @item @b{mrs_bool} @i{Timer}.upd(@b{mrs_timer}, @b{mrs_string}, @b{mrs_natural}) @* updates a timer control value where the second parameter is the string path and the third parameter is the value
  @item @b{mrs_bool} @i{Timer}.upd(@b{mrs_timer}, @b{mrs_string}, @b{mrs_string}) @* updates a timer control value where the second parameter is the string path and the third parameter is the value
  @item @b{mrs_natural} @i{Timer}.ival(@b{mrs_timer}, @b{mrs_string}) @* returns a natural value corresponding to the string representation of a time value in the specific format for the timer. ie "1s" may represent 1 second for a timer.
  @end itemize
@end itemize

@node Using
@subsubsection Using

Two examples show simple usage. These examples are in src/scheduler.cpp.

There are a few ways to specify an expression to be parsed.
@itemize
@item @b{new} EvExpr(marsym, Ex(@i{"x << 3"},@i{"'hello' + x >> Stream.opn"}),Rp(@i{"false"}));@*
      specifies a primary expression within the Ex constructor that is
      to be executed on every repetition of the event. Values to be used
      in the expression may be initialised in the first string, then
      used in the second string. The first string is evaluated as soon
      as the expression event is posted on some timer. The second string
      is executed on each repetition. The init string is optional within
      the Ex constructor (in fact the Rp exprsession may also have an
      init expression though it can be combined with the ExInit
      expression). However the expression inside the Rp Constructor
      specifies a repeat expression that determines if the event is to
      be repeated. This expression must have a type boolean.
@item @b{new} EvExpr(marsym, ExFile(@i{"filename.expr"}));@*
      the expressions for Ex and Rp can be read in from a file. This
      eliminates the need to recompile each time an expression needs to
      be adjusted. The file format is text where the lines expected by
      Ex and Rp are separated by titles:
  @itemize
  @item #ExInit: - specify an init variables expression.
  @item #ExExpr: - specify the expression to be repeated.
  @item #RpInit: - specify an init variables expression for the repeated expression. The repeat expression may share variables with the primary Ex expression so anything specified here can be specified in #ExInit:
  @item #RpExpr: - specify a boolean expression that determines if the expression event is to be repeated after each repetition. This expression is evaluated after the primary expression.
  @item #RpRate: - (Not implemented yet, pending) specify an expression that evalutes to a mrs_string that determines how far into the future the event is to be posted after it is evaluated. The result must have meaning in the current timer timebase.
  @end itemize
@end itemize

@node Extending
@subsubsection Extending

There are two ways to extend the libraries with your own functions. The
hard way is to hand code the function as a class in C++ then modify a
corresponding loadlib function in ExNode.cpp. The other way is to use
the code generation script in tools/scheduler.

@strong{Useful conversion functions}

There are a few built in functions for converting to and from the
std::string type. These functions can be used in your new functions.
@itemize
@item ltos(v) - converts v from a mrs_natural value to a std::string
@item dtos(v) - converts v from a mrs_real value to a std::string
@item btos(v) - converts v from a mrs_bool value to a std::string
@item stol(v) - converts v from a std::string value to a mrs_natural
@end itemize

@strong{Adding new libraries or library functions (C++ way)}

Library functions are added by creating a new ExFun class. The first
step is creating a new ExFun class for the new function. The second step
is adding it to the loadlib functions in ExNode.cpp.

@strong{Creating a new ExNode}

The ExFun class derives from the ExNode which is an expression tree
node. The example here is a function for extracting a substring from a
given string.

Functions taken a set number of parameters. The function class is
supplied information on the number of parameters and their types through
the setSignature function when the function class is instantiated in the
symbol table. For now we assume this set of parameters
(mrs_string,mrs_natural,mrs_natural) for the original string, the start
index, and the end index.

Creating an Exfun class requires the definition of the constructor, a
calc() method that returns the result of the function call, and a copy
method that returns a copy of the function without its parameters. The
example shows the

@float Figure, fig:mesy1
@example
@b{class} ExFun_StrSub : @b{public} ExFun @{ @b{public}:
    @b{ExFun_StrSub}() : @b{ExFun}(@t{"mrs_string"},@t{"String.sub(mrs_string,mrs_natural,mrs_natural"},@b{true}) @{ @}
    @b{virtual} ExVal @b{calc}() @{
        std::string str = params[0]->@b{eval}().@b{toString}();
        int s = params[1]->@b{eval}().@b{toNatural}();
        int e = params[2]->@b{eval}().@b{toNatural}();
        int l = str.@b{length}();
        @b{if} (s<0) @{ s=0; @} @b{else} @b{if} (s>l) @{ s=l; @}
        @b{if} (e<s) @{ e=s; @} @b{else} @b{if} (e>l-s) @{ e=l-s; @}
        @b{return} str.@b{substr}(s,e);
    @}
    ExFun* @b{copy}() @{ @b{return} @b{new} @b{ExFun_StrSub}(); @}
@};
@end example
@caption{String Substring ExFun class.}
@end float

Note that the constructor takes two parameters where t is the type that
the function evaluates to and n is the signature of the function. These
parameters are simply passed on to the ExFun parent constructor along
with a third boolean parameter for the pureness of the function.
Pureness is a flag that determines whether the function is free of
side-effects or not. If the parameters to the function can be determined
to be constant then a pure function can be evaluated at parse time to a
constant value.

The calc() method uses the three parameters from the params[] array.
These parameters are set at parse time and placed in the params[] array.
Each param[] is an expression so they are of type ExNode*. Therefore,
you need to evaluate each expression prior to using it. To evaluate,
call the eval() method of the ExNode not the calc() method. eval() will
make sure that each expression in a list of expressions will be
evaluated whereas calc() only calculates the current node.

@strong{Adding the function to the library}

The function can be added to the library by adding a line to the
loadlib_String method in ExNode.cpp. The addReserved call made to the
symbol table adds a reserved word. There is some flexibility in how the
name appears in the symbol table which in turn defines how it may be
used in an expression. The path to a function is separated by the '.'
symbol. Multiple names for a segment of the path can be defined by
separating them with the '|' symbol where the first among several is the
'true' name. For example String|Str|S.sub defines three different
leading names where the true name is String.sub but S.sub will get the
same thing. The same is possible for parameter tuples but not the
individual parameters. For example Real|R.cos(mrs_real)|(mrs_natural)
allows the call Real.cos(0.5) as well as Real.cos(1) as 1 is a natural
and not a real. This type information is used to type check function
calls in the parser.

@float Figure, fig:mesy2
@example
st->@b{addReserved}(@t{"String|S.sub(mrs_string,mrs_natural,mrs_natural)"},
                @b{new} @b{ExFun_StrSub}(@t{"mrs_string"},
                                 @t{"String.sub(mrs_string,mrs_natural,mrs_natural)"}));
@end example
@caption{Adding a function to the library.}
@end float

The second parameter to the addReserved call is a new instantiation of
the function object. Here the return type is the first parameter to the
constructor and the 'correct' or 'true' full function call is the second
parameter. This information is used for type checking parameters. While
type errors are not possible if the first parameter to the addReserved
call is correct, the type information in the second parameter to the
constructor is actually used for type coercion - promoting naturals to
reals, etc.

@strong{Adding new libraries or library functions (Code Gen way)}

In the tools/scheduler directory is a python script for generating
library functions from a simplified source code. The easiest way to
explain the process is through an example:

@float Figure, fig:mesy3
@example
 1: @b{lib} Foo|F.Bar|B
 2:
 3: @b{pure} mrs_string @b{fun}|@b{alt}(mrs_real a, mrs_natural b)
 4:     mrs_string s="hello";
 5:     mrs_bool x;
 6: @{
 7:     mrs_natural z=a+b;
 8:     @b{if} (x) @{ s=s+" "+ltos(z); @}
 9:     x = z < 0;
10:     @b{return} s;
11: @}
@end example
@caption{Adding a function to the library.}
@end float

Though not a useful function it does demonstrate the full extent of the
code generation syntax.

@b{Line 1}. library definition starts with keyword 'lib' the names following
denote a path to the library. The true path is Foo.Bar, all functions
defined after this statement until a new lib definition will be in this
library. This means that the function fun is called by 'Foo.Bar.fun'.
Alternate names or aliases for portions of the path can be defined using
the | symbol. In the above example F is an alias for Foo so the path to
fun could also be written as 'Foo.B.fun' or 'F.B.fun' etc.

@b{Line 3}. the function definition may start with 'pure' where pure implies
that if the parameters to the function are constants then the function
can be evaluated at parse time to a constant, ie no side-effects. If
pure isn't specified then the function is not pure. the return type must
be a type supported by the ExVal class (names starting with 'mrs_'). The
function name can also have aliases divided by the | symbol where the
first name is the true name. Parameters must be defined using the 'mrs_'
names.

@b{Line 4}. Normally functions do not have state but as a bonus variables
whose values persist may defined after the parameters definition and
prior to the opening function body brace. These types can be the 'mrs_'
types or valid C++ types.

@b{Line 6}. The function body begins with a opening brace @{.

@b{Line 7-10}. The function body contains valid C++ code and will likely use
the parameter values defined on line 3.

@b{Line 11}. The function body ends with a closing brace @}.

@node Marsyas Expression Examples
@subsubsection Marsyas Expression Examples


@float Figure, fig:wschev1
@example
@b{#include} @t{<stdio.h>}
@b{#include} @t{"MarSystemManager.h"}
@b{#include} @t{"EvExpr.h"}

@b{using} @b{namespace} std;
@b{using} @b{namespace} Marsyas;

void @b{sched1}()
@{
  MarSystemManager mng;

  MarSystem* fanin = mng.@b{create}(@t{"Fanin"}, @t{"fanin"});
  fanin->@b{addMarSystem}(mng.@b{create}(@t{"SineSource"}, @t{"src1"}));
  fanin->@b{addMarSystem}(mng.@b{create}(@t{"SineSource"}, @t{"src2"}));
  fanin->@b{updctrl}(@t{"SineSource/src1/mrs_real/frequency"},3000.0);
  fanin->@b{updctrl}(@t{"SineSource/src2/mrs_real/frequency"},1000.0);

  MarSystem* series = mng.@b{create}(@t{"Series"}, @t{"series"});
  series->@b{addMarSystem}(fanin);

  series->@b{addMarSystem}(mng.@b{create}(@t{"AudioSink"}, @t{"dest"}));
  series->@b{updctrl}(@t{"AudioSink/dest/mrs_bool/initAudio"}, @b{true});


@b{#if} 0
  @i{// using aliases makes this a little more readable, see the next bit}
  EvExpr* e = @b{new} @b{EvExpr}(series,
    @b{Ex}(@t{"Fanin/fanin/SineSource/src1/mrs_real/frequency << 120. + 3000. * R.rand(), \}
@t{        Fanin/fanin/SineSource/src2/mrs_real/frequency << 120. + 800. * R.rand(),"}
       @t{"'src1='+Fanin/fanin/SineSource/src1/mrs_real/frequency+ \}
@t{        ' src2='+Fanin/fanin/SineSource/src2/mrs_real/frequency+'}@t{\n}@t{'>>Stream.op"}),
    @b{Rp}(@t{"true"}));

@b{#else}
  EvExpr* e = @b{new} @b{EvExpr}(series,
        @i{// First line to Ex will be the init expression, run once, when event is posted}
    @b{Ex}(@t{"Fanin/fanin/SineSource/src1/mrs_real/frequency >> @@freq1, \}
@t{        Fanin/fanin/SineSource/src2/mrs_real/frequency >> @@freq2 "},
       @i{// Second line to Ex is the expression, repeated each time the event is posted}
       @t{"freq1 << 120. + 3000. * R.rand(),\}
@t{        freq2 << 120. + 800. * R.rand(),\}
@t{        'src1=' + freq1 + ' src2=' + freq2 + '}@t{\n}@t{' >> Stream.op"}),
    @b{Rp}(@t{"true"}));

@b{#endif}

  e->@b{set_repeat}(@b{Repeat}(@t{"0.25s"}));

  series->@b{updctrl}(@b{TmTime}(@t{"TmSampleCount/Virtual"},@t{"0s"}), e);

  @b{for} (int i=1;i<100;i++) series->@b{tick}();

  @b{delete} series;
@}
@end example
@caption{How to generate random sine waves}
@end float

@float Figure, fig:wschev2
@example
void @b{sched2}()
@{
  MarSystemManager mng;

  MarSystem* fanin = mng.@b{create}(@t{"Fanin"}, @t{"fanin"});
  fanin->@b{addMarSystem}(mng.@b{create}(@t{"SineSource"}, @t{"src1"}));
  fanin->@b{addMarSystem}(mng.@b{create}(@t{"SineSource"}, @t{"src2"}));
  fanin->@b{updctrl}(@t{"SineSource/src1/mrs_real/frequency"},400.0);  @i{// A}

  fanin->@b{updctrl}(@t{"SineSource/src2/mrs_real/frequency"},554.37); @i{// C#}
  fanin->@b{updctrl}(@t{"SineSource/src3/mrs_real/frequency"},659.26); @i{// E}

  MarSystem* series = mng.@b{create}(@t{"Series"}, @t{"series"});
  series->@b{addMarSystem}(fanin);

  series->@b{addMarSystem}(mng.@b{create}(@t{"AudioSink"}, @t{"dest"}));
  series->@b{updctrl}(@t{"AudioSink/dest/mrs_bool/initAudio"}, @b{true});

  EvExpr* e =
    @b{new} @b{EvExpr}(series,
      @b{Ex}(@t{"tmr<<Timer.cur"},@t{"tmr.prefix + ' ' + tmr.time + '}@t{\n}@t{' >> Stream.op"}),
      @b{Rp}(@t{"true"}));

  e->@b{set_repeat}(@b{Repeat}(@t{"0.25s"}));

  series->@b{updctrl}(@b{TmTime}(@t{"TmSampleCount/Virtual"},@t{"0s"}), e);

  @b{for} (int i=1;i<100;i++) series->@b{tick}();

  @b{delete} series;
@}
@end example
@caption{Printing the time of the current timer}
@end float

